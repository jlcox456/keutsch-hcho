%{
  #include "SB.h"
  #define BCtr_BASE 0x20
  #define BCTR_N_BIN_SPECS @NAB@
  /** 
     BCtr_col.tmc generated from BCtr/TM/BCtr_col.tmc.in
     
     NB_TOTAL must be the sum of the elements of NB.

     BCTR_BIN_SIZE is the length of BCtr_Bins defined in BCtr.tmc
     TMC does not understand #defines, so it must be hard
     coded, but this is here to remind. The +6 is for the
     Status and NWords plus the 4 words of ancillary data
     (IPnum, NTrigger[2] and LaserV)

     The pack_mread_request() call below also needs to be
     adjusted.

     The pack_mread_request() call below also needs to be
     adjusted. The hex value between '|' and '@' needs to
     be BCTR_BIN_SIZE-2 (Two for the status(20) and NWords(21)
     values which are not read from address 22)

     For the values listed above, we have:
        BCTR_BIN_SIZE = 101*2 + 6 = 208
        NWORDS_FIFO = BCTR_BIN_SIZE-2 = 206 = 0xCE
   */
  unsigned short NA[BCTR_N_BIN_SPECS] = { @NA@ };
  unsigned short NB[BCTR_N_BIN_SPECS] = { @NB@ };
  subbus_mread_req *BCtr_req;
  
  
  void BCtr_init() {
    int i;
    unsigned short status = 1;
    if (SB.BCtr) {
      SB.BCtr->sbwr(BCtr_BASE, 0);
      SB.BCtr->sbwr(BCtr_BASE, 0x8000);
      while (status) {
        status = SB.BCtr->sbrw(BCtr_BASE);
      }
      for (i = 0; i < BCTR_N_BIN_SPECS; ++i) {
        SB.BCtr->sbwr(BCtr_BASE+3+2*i, NA[i]);
        SB.BCtr->sbwr(BCtr_BASE+4+2*i, NB[i]);
      }
      BCtr_req = SB.BCtr->pack_mread_request(BCTR_BIN_SIZE, "20,21|CE@22");
    } else {
      nl_error(2, "BCtr lib not found");
    }
  }

  void BCtr_collect(unsigned short *Bins) {
    unsigned short nw;
    static unsigned short saw_nw = 0;
    if (SB.BCtr) {
      SB.BCtr->mread_subbus_nw(BCtr_req, Bins, &nw);
    }
    if (nw != saw_nw) {
      nl_error(0, "nw = %u", nw);
      saw_nw = nw;
    }
    while (nw < @NW@) {
      Bins[nw++] = 0;
    }
  }
%}
TM INITFUNC BCtr_init();

