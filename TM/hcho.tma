%{
  int scan_requested = 0;
  int chop_exit_requested = 0;
%}

State Init {
      > Telemetry Start
   +1 > Laser Set Scan Start 100
      > Laser Set Scan Stop 600
      > Laser Set Scan Step 1
      > Laser Offline Delta Set -30
      > Laser NPoints Online Set 50
      > Laser NPoints Offline Set 50
      > Laser Drift Limit Set 30
  +10 > Log Initiating PPS Synchronization
      Validate PPS_synch;
}

State Shutdown {
  +2 > Quit
}

Partition

%{
  double PPS_integral;
  #define GP 1.1e4
  #define GI 1e3
  #define PPS_CLIP_LIMIT 30000
  #define PPS_INT_LIMIT (PPS_CLIP_LIMIT/GI)
  #define PPS_SETPOINT (3.0)
  /* UpdatePeriod = 5; */
%}

State PPS_idle {}

State PPS_synch nolog {
  { if (PPS_min_drift > PPS_SETPOINT &&
        PPS_min_drift < PPS_SETPOINT+3.000) {
      Validate PPS_rate_synch;
    } else if (PPS_min_drift < PPS_SETPOINT &&
        PPS_min_drift > PPS_SETPOINT-75.0) {
      Validate PPS_synch3;
    }
  }
  +1 > PPS Offset Adjust 30000
  +7 Validate PPS_synch;
}

State PPS_synch3 nolog {
   +1 { double adj;
        if (PPS_min_drift > PPS_SETPOINT) Validate PPS_rate_synch;
        else {
          unsigned short adju;
          adj = (PPS_SETPOINT+2.0-PPS_min_drift)*400;
          if (adj > 30000) adj = 30000;
          adju = adj;
          ci_sendfcmd(0, "PPS Offset Adjust %u\n", adju);
        }
      }
   +7 Validate PPS_synch3;
}

State PPS_rate_synch {
  {
    PPS_integral = PPS_integral + (PPS_min_drift-PPS_SETPOINT);
    if (PPS_integral > PPS_INT_LIMIT) PPS_integral = PPS_INT_LIMIT;
    else if (PPS_integral < -PPS_INT_LIMIT) PPS_integral = -PPS_INT_LIMIT;
  }
  { double rate_adj;
    rate_adj = (PPS_min_drift-PPS_SETPOINT) * GP + PPS_integral * GI;
    if (rate_adj > PPS_CLIP_LIMIT) rate_adj = PPS_CLIP_LIMIT;
    else if (rate_adj < -PPS_CLIP_LIMIT) rate_adj = -PPS_CLIP_LIMIT;
    if (rate_adj != PPS_fine)
      ci_sendfcmd(2, "PPS Rate Adjust %.0lf\n", rate_adj);
  }
}

Partition

%{
  double CellP_integral;
  #define CELLP_GP (100)
  #define CELLP_GI (20)
  #define CELLP_CLIP_LIMIT 10000
  #define CELLP_INT_LIMIT (CELLP_CLIP_LIMIT/CELLP_GI)
  #define CELLP_SETPOINT (115.0)
  /* UpdatePeriod = 5; */
%}

State CellP_idle {}

State CellP_control nolog {
  +1
  { double err_term, rate_adj;
    err_term = (convert(OmegaP)-CELLP_SETPOINT);
    CellP_integral += err_term;
    if (CellP_integral > CELLP_INT_LIMIT)
      CellP_integral = CELLP_INT_LIMIT;
    else if (CellP_integral < -CELLP_INT_LIMIT)
      CellP_integral = -CELLP_INT_LIMIT;
    rate_adj = 5000 - err_term * CELLP_GP -
      CellP_integral * CELLP_GI;
    if (rate_adj > CELLP_CLIP_LIMIT)
      rate_adj = CELLP_CLIP_LIMIT;
    else if (rate_adj < 0) rate_adj = 0;
    if (rate_adj != FC2_Set)
      ci_sendfcmd(2, "Flow Bypass Set SCCM %.0lf\n", rate_adj);
    Validate CellP_control;
  }
}

Partition
# This partition tracks scans, locating the laser voltage
# corresponding to the peak normalized counts from the reference cell.
# If peak-finding is enabled, it sets the online position after the
# scan.

%{
  #include <stdbool.h>
  bool find_peak = true;
%}

{
  int scanning;
  double max_norm_ref_cts;
  HtrDAC_mV_t cur_peak_laser_V, peak_laser_V;

  depending on (BCtr_LaserV once, BCtr_0_a once, BCtr_LasIn_mW once, BCtr_LVstat once) {
    double norm_ref_cts;
    norm_ref_cts = BCtr_0_a/convert(BCtr_LasIn_mW);
    if (BCtr_LVstat & 1) {
      if (scanning == 0) {
        scanning = 1;
        max_norm_ref_cts = norm_ref_cts;
        cur_peak_laser_V = BCtr_LaserV;
      } else {
        if (norm_ref_cts > max_norm_ref_cts) {
          max_norm_ref_cts = norm_ref_cts;
          cur_peak_laser_V = BCtr_LaserV;
        }
      }
    }
  }
}

State Laser_Scan_Watch {
  hold until (BCtr_LVstat & 1);
  hold until (!(BCtr_LVstat & 1));
  { if (find_peak && scanning) {
      peak_laser_V = cur_peak_laser_V;
      if (convert(peak_laser_V) > convert(LV_online)+Drift_Limit ||
          convert(peak_laser_V) < convert(LV_online)-Drift_Limit) {
        nl_error(2,
         "Peak detected at %.1lf mV outside drift limit %d from %.1lf",
         convert(peak_laser_V), Drift_Limit, convert(LV_online));
      } else {
        ci_sendfcmd(0, "Laser Set Online %.1lf\n",
           convert(peak_laser_V));
      }
    }
    scanning = 0;
    Validate Laser_Scan_Watch;
  }
}

Partition
# This partition controls chopping and scanning

State Chop_Idle {}

State Chop_Period_1 {
  > Laser Command Scan Start
  Hold Until (BCtr_LVstat & 1);
  Hold Until (!(BCtr_LVstat & 1) && !scanning);
  > Laser Command Chop Mode Begin
  Hold Until (SWStat == SWS_TIME_WARP) or 1:00;
  Validate Chop_Period_1;
}

State Chop_Period_5 {
  > Laser Command Scan Start
  Hold Until (BCtr_LVstat & 1);
  Hold Until (!(BCtr_LVstat & 1) && !scanning);
  > Laser Command Chop Mode Begin
  Hold Until (SWStat == SWS_TIME_WARP) or 5:00;
  Validate Chop_Period_5;
}

State Chop_Period_10 {
  > Laser Command Scan Start
  Hold Until (BCtr_LVstat & 1);
  Hold Until (!(BCtr_LVstat & 1) && !scanning);
  > Laser Command Chop Mode Begin
  Hold Until (SWStat == SWS_TIME_WARP) or 10:00;
  Validate Chop_Period_10;
}

State Chop_Period_30 {
  > Laser Command Scan Start
  Hold Until (BCtr_LVstat & 1);
  Hold Until (!(BCtr_LVstat & 1) && !scanning);
  > Laser Command Chop Mode Begin
  Hold Until (SWStat == SWS_TIME_WARP) or 30:00;
  Validate Chop_Period_30;
}

Partition
# This partition monitors chopping and adjust the online position
# to remain on the power-normalized peak. It will also monitor
# online and offline power and adjust THG to achieve even power
# in both positions. (It is also possible to consider trying to
# update THG whenever the laser voltage changes, but that is
# probably harder.)

%{
  double pmncts; // prev_mean_normalized_online_cts;
  double cncts;  // cur_normalized_online_cts;
  double cmncts; // cur_mean_normalized_online_cts;
  HtrDAC_mV_t prev_LV, cur_LV;
  int np_online;
  bool dither_enable = false;
%}

State Chop_Active {
  { if (BCtr_LVstat&0x8) {
      if (BCtr_LVstat&0x2) {
        cur_LV = BCtr_LaserV;
        cncts += BCtr_0_a/convert(BCtr_LasIn_mW);
        ++np_online;
      } else if (np_online) {
        cmncts = cncts/np_online;
        if (dither_enable) {
          ci_sendfcmd(2, "Laser Command Dither Online %s\n",
            ((cmncts > pmncts) != (cur_LV > prev_LV)) ?
            "Up" : "Down");
        }
        pmncts = cmncts;
        prev_LV = cur_LV;
        cncts = 0;
        np_online = 0;
      }
    } else {
      prev_LV = 0;
      np_online = 0;
      cncts = 0;
      pmncts = 0;
    }
  }
}
