%{
  int scan_requested = 0;
  int chop_exit_requested = 0;
%}

State Init {
      > Telemetry Start
   +1 > Laser Set Scan Start 100
      > Laser Set Scan Stop 600
      > Laser Set Scan Step 1
      > Laser Offline Delta Set -30
      > Laser NPoints Online Set 50
      > Laser NPoints Offline Set 50
      > Laser Drift Limit Set 30
  +10 > Log Initiating PPS Synchronization
      Validate PPS_synch;
}

State Shutdown {
  +2 > Quit
}

Partition

%{
  double PPS_integral;
  #define GP 1.1e4
  #define GI 1e3
  #define PPS_CLIP_LIMIT 30000
  #define PPS_INT_LIMIT (PPS_CLIP_LIMIT/GI)
  #define PPS_SETPOINT (-47.0)
  /* UpdatePeriod = 5; */
%}

State PPS_idle {}

State PPS_synch nolog {
  { if (PPS_min_drift > PPS_SETPOINT &&
        PPS_min_drift < PPS_SETPOINT+3.000) {
      Validate PPS_rate_synch;
    } else if (PPS_min_drift < PPS_SETPOINT &&
        PPS_min_drift > PPS_SETPOINT-75.0) {
      Validate PPS_synch3;
    }
  }
  +1 > PPS Offset Adjust 30000
  +7 Validate PPS_synch;
}

State PPS_synch3 nolog {
   +1 { double adj;
        if (PPS_min_drift > PPS_SETPOINT) Validate PPS_rate_synch;
        else {
          unsigned short adju;
          adj = (PPS_SETPOINT+2.0-PPS_min_drift)*400;
          if (adj > 30000) adj = 30000;
          adju = adj;
          ci_sendfcmd(0, "PPS Offset Adjust %u\n", adju);
        }
      }
   +7 Validate PPS_synch3;
}

State PPS_rate_synch {
  {
    PPS_integral = PPS_integral + (PPS_min_drift-PPS_SETPOINT);
    if (PPS_integral > PPS_INT_LIMIT) PPS_integral = PPS_INT_LIMIT;
    else if (PPS_integral < -PPS_INT_LIMIT) PPS_integral = -PPS_INT_LIMIT;
  }
  { double rate_adj;
    rate_adj = (PPS_min_drift-PPS_SETPOINT) * GP + PPS_integral * GI;
    if (rate_adj > PPS_CLIP_LIMIT) rate_adj = PPS_CLIP_LIMIT;
    else if (rate_adj < -PPS_CLIP_LIMIT) rate_adj = -PPS_CLIP_LIMIT;
    if (rate_adj != PPS_fine)
      ci_sendfcmd(2, "PPS Rate Adjust %.0lf\n", rate_adj);
  }
}

Partition

%{
  double CellP_integral;
  #define CELLP_GP (100)
  #define CELLP_GI (20)
  #define CELLP_CLIP_LIMIT 10000
  #define CELLP_INT_LIMIT (CELLP_CLIP_LIMIT/CELLP_GI)
  #define CELLP_SETPOINT (115.0)
  /* UpdatePeriod = 5; */
%}

State CellP_idle {}

State CellP_control nolog {
  +1
  { double err_term, rate_adj;
    err_term = (convert(OmegaP)-CELLP_SETPOINT);
    CellP_integral += err_term;
    if (CellP_integral > CELLP_INT_LIMIT)
      CellP_integral = CELLP_INT_LIMIT;
    else if (CellP_integral < -CELLP_INT_LIMIT)
      CellP_integral = -CELLP_INT_LIMIT;
    rate_adj = 5000 - err_term * CELLP_GP -
      CellP_integral * CELLP_GI;
    if (rate_adj > CELLP_CLIP_LIMIT)
      rate_adj = CELLP_CLIP_LIMIT;
    else if (rate_adj < 0) rate_adj = 0;
    if (rate_adj != FC2_Set)
      ci_sendfcmd(2, "Flow Bypass Set SCCM %.0lf\n", rate_adj);
    Validate CellP_control;
  }
}

Partition

{
  int scanning;
  Laser_mW cur_LasIn_mW;
  double max_norm_ref_cts;
  HtrDAC_mV_t cur_peak_laser_V, peak_laser_V;
  HtrDAC_mV_t prev_laser_V;
  HtrDAC_mV_t cur_LV_start;
  HtrDAC_mV_t cur_LV_stop;
  HtrDAC_mV_t cur_LV_step;

  cur_LasIn_mW = convert(LasIn_mW);
  cur_LV_start = LV_start;
  cur_LV_stop = LV_stop;
  cur_LV_step = (LV_step+7)/8;

  depending on (BCtr_LaserV once, BCtr_0_a once) {
    double norm_ref_cts;
    norm_ref_cts = BCtr_0_a/cur_LasIn_mW;
    if (BCtr_LaserV == cur_LV_start) {
      scanning = 1;
      max_norm_ref_cts = norm_ref_cts;
      cur_peak_laser_V = BCtr_LaserV;
    } else if (scanning == 1) {
      if (BCtr_LaserV == prev_laser_V) {
        scanning = 0;
      } else {
        if (norm_ref_cts > max_norm_ref_cts) {
          max_norm_ref_cts = norm_ref_cts;
          cur_peak_laser_V = BCtr_LaserV;
        }
        if (BCtr_LaserV >= cur_LV_stop-cur_LV_step) {
          scanning = 0;
          peak_laser_V = cur_peak_laser_V;
        }
      }
    }
    prev_laser_V = BCtr_LaserV;
  }
}

State Laser_Scan_Watch {
  hold until (LV_status & 1);
  > Log Scan Start Observed
  hold until (!(LV_status & 1) && !scanning);
  > Log Scan Stop Observed
  +1 { 
       if (convert(peak_laser_V) > convert(LV_online)+Drift_Limit ||
           convert(peak_laser_V) < convert(LV_online)-Drift_Limit) {
         nl_error(2,
          "Peak detected at %.1lf mV outside drift limit %d from %.1lf",
          convert(peak_laser_V), Drift_Limit, convert(LV_online));
       } else {
         ci_sendfcmd(0, "Laser Set Online %.0lf\n",
            convert(peak_laser_V));
         ci_sendfcmd(0, "Laser Set Offline %.0lf\n",
            convert(peak_laser_V) + Offline_Delta);
       }
       Validate Laser_Scan_Watch;
     }
}

State Laser_Scan_No_Watch {}

Partition

{
  int cur_npts;
  int is_online;
  DS_POINTS cur_npts_online;
  DS_POINTS cur_npts_offline;
  cur_npts_online = NPts_Online;
  cur_npts_offline = NPts_Offline;
}

State Chop_Idle {}

State Chop_Active {
  { cur_npts = 0;
    is_online = 0;
  }
  depending on (10 Hz) {
    if (is_online) {
      if (--cur_npts <= 0) {
        ci_sendfcmd(2,"Laser Command Drive Offline\n");
        cur_npts = cur_npts_offline-1;
        is_online = 0;
      }
    } else if (--cur_npts <= 0) {
      if (scan_requested) {
        scan_requested = 0;
        Validate Chop_Scan;
      } else if (chop_exit_requested) {
        chop_exit_requested = 0;
        Validate Chop_Idle;
      } else {
        is_online = 1;
        ci_sendfcmd(2,"Laser Command Drive Online\n");
        cur_npts = cur_npts_online-1;
      }
    }
  }
  +1:00 { scan_requested = 1; }
}

State Chop_Scan {
  +1 { ci_sendfcmd(0, "Laser Set Setpoint %.0lf\n", convert(LV_start)); }
  +2 > Laser Command Scan Start
  hold until (LV_status & 1);
  hold until (!(LV_status & 1) && !scanning);
  Validate Chop_Active;
}
